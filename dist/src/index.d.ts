import { BindingIdentifier, FunctionDeclaration, IdentifierExpression, Node, Script, VariableDeclarator, AssignmentTargetIdentifier, ClassDeclaration, FunctionExpression, AssignmentExpression, ClassExpression, Statement, Expression } from 'shift-ast';
import { Scope, ScopeLookup, Variable, Reference, Declaration } from 'shift-scope';
import { RefactorPlugin } from './refactor-plugin';
import './refactor-plugin-common';
import './refactor-plugin-unsafe';
import { Replacer, SelectorOrNode } from './types';
export declare type SimpleIdentifier = BindingIdentifier | IdentifierExpression | AssignmentTargetIdentifier;
export declare type SimpleIdentifierOwner = AssignmentExpression | ClassDeclaration | ClassExpression | FunctionDeclaration | FunctionExpression | VariableDeclarator;
export { isLiteral } from './util';
export declare function $r(ast: string | Node, { autoCleanup }?: {
    autoCleanup?: boolean | undefined;
}): ((selector: string) => any) & RefactorSession;
export declare class RefactorSession {
    ast: Node;
    autoCleanup: boolean;
    dirty: boolean;
    _scopeMap: WeakMap<Variable, Scope>;
    _scopeOwnerMap: WeakMap<Node, Scope>;
    _parentMap: WeakMap<Node, Node>;
    _variables: Set<Variable>;
    _replacements: WeakMap<object, any>;
    _deletions: WeakSet<object>;
    _insertions: WeakMap<object, any>;
    _lookupTable: ScopeLookup | undefined;
    constructor(ast: string | Node, { autoCleanup }?: {
        autoCleanup?: boolean | undefined;
    });
    use<T extends RefactorPlugin>(Plugin: new (session: RefactorSession) => T): void;
    static parse(src: string): Script;
    _rebuildParentMap(): void;
    rename(selector: SelectorOrNode, newName: string): this;
    _renameInPlace(lookup: Variable, newName: string): void;
    delete(selector: SelectorOrNode): this;
    replaceAsync(selector: SelectorOrNode, replacer: (node: Node) => Promise<Node | string>): Promise<boolean[]>;
    replace(selector: SelectorOrNode, replacer: Replacer): any;
    replaceRecursive(selector: SelectorOrNode, replacer: Replacer): this;
    _insert(selector: SelectorOrNode, replacer: Replacer, after?: boolean): this;
    findParents(selector: SelectorOrNode): any;
    insertBefore(selector: SelectorOrNode, replacer: Replacer): this;
    insertAfter(selector: SelectorOrNode, replacer: Replacer): this;
    _queueDeletion(node: Node): void;
    _queueReplacement(from: Node, to: Node): void;
    getLookupTable(): ScopeLookup;
    _rebuildScopeMap(): void;
    _isDirty(): boolean;
    _makeDirty(): void;
    validate(): any;
    cleanup(): any;
    query(selector: string): any;
    find(selector: string): any;
    queryFrom(astNodes: Node | Node[], selector: string): any;
    findMatchingExpression(sampleSrc: string): Expression[];
    findMatchingStatement(sampleSrc: string): Statement[];
    findOne(selector: string): any;
    findReferences(node: SimpleIdentifier | SimpleIdentifierOwner): Reference[];
    findDeclarations(node: SimpleIdentifier | SimpleIdentifierOwner): Declaration[];
    closest(originSelector: SelectorOrNode, closestSelector: string): any;
    lookupScope(variableLookup: Variable | SimpleIdentifierOwner | SimpleIdentifier): Scope | undefined;
    getInnerScope(node: FunctionDeclaration): Scope | undefined;
    lookupVariable(node: SimpleIdentifierOwner | SimpleIdentifier): Variable;
    lookupVariableByName(name: string): Variable[];
    print(ast?: Node): any;
}
